package com.binarytree;
// - - - - -树- - - - - -
//树的存储与链表类似
//有一个专门的类,结点
//拿到根节点,后续的节点可以一一拿到

//多种表示方式
//1.双亲表示法(直译parent 其实只指一个 又可以叫父亲表示法)
//class Node{
//    String val;
//    Node parent;
//}很少去使用->不方便去找子节点<-特定情况下的解决方案

//2.孩子表示法 ->最常用的表示形式
//class Node{
//    String val;
//    List<Node> children;
//}

//3.孩子双亲表示法 -> 功能最强大的表示形式
//class Node{
//    String val;
//    Node parent;
//    List<Node> children;
//}

//4.孩子兄弟表示法 ->特定场景解决方案
//class Node{
//    String val;
//    Node firstChild;
//    List<Node> brotherNodes;
//}



// - - - - -二叉树- - - - - -
//任意节点的度不能超过二(可以小于二:即单个节点\一个节点也不存在\只有一个子树也算是二叉树)
//特殊二叉树:满二叉树   完全二叉树
    //满二叉树:没有只存在一个分支的情况
    //完全二叉树:在满二叉树的基础上,缺失了右下角
        //更严格的柏树完全二叉树的规则
        //第一阶段中,任意一个访问到的节点,都应该有两个子树
        //如果遇到以下情况:
        //a)没有子树的节点,进入第二阶段
        //b)只有左子树的节点,进入第二阶段
        //c)只有柚右子树的节点,直接判定非二叉树
        //第二件段中,要求每个节点都没有子树
        //一旦遇到了有子树的节点,判定为非二叉树

//树有一个很重要的用途,支持高效率的查找操作(不是针对普通的树能高效的):如后续的"平衡二叉搜索树"
public class Text {
    public static void main(String[] args) {

    }
}
